# 面试题2
[toc]
## ECMAScript对象的继承结构
继承的规律：
1. 对象继承的重点是Object.prototype
2. 所有函数默认的显示原型(即函数的prototype)都继承Object.prototype
3. 谁的实例，这个实例就继承税的prototype。
	1. 所有的函数，都被看做是Function的实例，所以都继承Function.prototype
	2. 所有的数组，都被看做是Array的实例，所以都继承Array.prototype
	3. 所有的正则，都被看做是RegExp的实例，所以都继承RegExp.prototype

例如： function fn() {}
fn是Function的实例，所以继承Function.prototype。
fn.prototype继承Object.prototype。
new fn()是fn的实例，所以继承fn.prototype。

## 什么是事件冒泡、捕获？
事件冒泡：子元素事件的触发会影响父元素事件：
开关事件冒泡:
A: 开启事件冒泡：element.addEventListener(eventName, handler, false);
B: 关闭事件冒泡：假设传统方式事件的返回值为e,就可以通过e.stopPropagation()来关闭事件冒泡;
事件捕获:父元素的事件会影响子元素的事件；
开启事件捕获:element.addEventListener(eventName, handler, true)
## 如何组织事件冒泡和默认事件?
举例说明什么是事件冒泡，何时组织事件冒泡。
如果<p>是在<div>里面，那么呢，<p>有一个onclick事件，<div>也有onclick事件，为了触发<p>的点击事件时，不触发父元素的点击事件，那么就需要调用如下函数，阻止事件冒泡。
阻止事件冒泡函数:
```js
function stopBubble(e) {
	if (e && e.stopPropagation) {
    	// 非IE
    	e.stopPropagation();
    } else {
    	// IE
        window.event.cancelBubble = true;
    }
}
```
阻止默认事件:
```js
function stopDefault(e) {
	// 阻止默认浏览器动作(W3C)
    if (e && e.preventDefault) {
    	e.preventDegault();
    } else {
    	// IE中阻止函数默认动作的方式
        window.event.returnValue = false;
    }
    return false;
}
```
