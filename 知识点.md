# 知识点总结
[toc]
## HTML5有哪些新特性，HTML5 新白哦前的浏览器兼容问题如何处理?
HTML5新增了以下的几大类元素:
+ 内容元素: article, footer, header, nav, section。
+ 表单控件: canlendar, date, time, email, url, search。
+ 控件元素: webworker, websockt, Geolocation。

移除的元素有:
+ 显现层元素: basefont, big, center, font, s, strike, tt, u。
+ 性能较差元素: frame， frameset, noframes。

HTML5已经形成了最终的标准，概况来讲，它主要是关于图像，位置，存储，多任务等功能的增加。
新增的元素有绘画canvas,用于媒介回放的video和audio元素，本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失，而sessionStorage的数据在浏览器关闭后自动删除。
新的技术: canvas, svg, webworker, websocket, Geolocation。
## HTML语义化的理解
1. HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
2. 即使在没有样式CSS的情况下也能以一种文档格式显示，并且是容易阅读的;
3. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；
4. 使阅读代码的人更容易将网站分块，便于阅读、维护和理解。

## 对WEB标准以及W3C的理解与认识
1. 标签闭合、标签小写、不乱嵌套，提高SEO，使用外链CSS和JS脚本，结构行为表现的分离。
2. 文件下载与页面速度更快，内容能被更多的用户访问，也能被更广泛的设备所读写，更少的代码和组件。
3. 容易维护、改版方便，不需要变动页面内容，提供打印版本而不需要复制内容，提高网站易用性。

## Iframe的作用
Iframe是用来在网页中插入第三方页面，早起的页面使用iframe主要是用于导航栏这种很多页面都相同的部分，这样可以在切换页面的时候避免重复下载。
优点: 便于修改，模块分离，像一些信息管理系统会用到。但是现在基本上不推荐使用。除非特殊需要，一般不推荐使用。
缺点:
1. iframe的创建比一般的DOM元素满了1-2个数量级。
2. iframe的标签会阻塞页面的加载，如果页面的onload事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好。在Safari和Chrome中可以通过js动态设置iframe的src属性来避免阻塞。
3. iframe对于SEO不友好，替代方案一般就是动态语言的Incude机制和ajax动态填充内容等。

## CSS3新特性有哪些?
1. 颜色: 新增rgba， HSLA模式。
2. 文字阴影(text-shadow)
3. 边框: 圆角(border-radious) 边框阴影(box-shadow)
4. 盒子模型: box-sizing
5. 背景: background-size 设置背景图片的尺寸 background-origin 设置背景图片的原点 background-clip 设置北京图片的裁切区域，以','分隔可以设置多背景，用于自适应布局。
6. 渐变: linear-gradient、 radial-gradient
7. 过度: transition, 可以实现动画
8. 自定义动画
9. 在CSS3 中唯一引入的伪元素是: selection。
10. 媒体查询，多栏布局
11. border-image
12. 2D转换: transform: translate(x, y) rotate(x, y) skew(x, y) scale(x, y)
13. 3D转换

## CSS中的渐进增强，优雅降级之间的区别
优雅降级和渐进增强印象中是随着CSS3流出来的一个概念。由于低级浏览器不支持CSS3，但CSS3的效果又太优秀不忍放弃，所以在高级浏览中使用CSS3而低级浏览器只保证最基本的功能。乍一看这两个概念差不多，都是在关注不同浏览器下的不同体验，关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。
优雅降级观点仍为应该针对那些最高级、最完善的浏览器来设计。渐进增强观点则仍为应该关注内容本身。
具体做法是根据不同浏览器厂商，在CSS3属性前面加不同的头来保证在不同浏览器内正常显示。
## 对BFC规范的理解
定义：BFC(Block formatting context)直译为"块级格式化上下文"，他是一个独立的渲染区域。只有Block-level box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
布局规则:
A: 内部的Box会在垂直方向，一个接一个地放置。
B: Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻的Box的margin会发生重叠。
C: 每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
D: BFC的区域不会与float box重叠。
E: BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面的元素。反之也如此。
F: 计算BFC的高度时，浮动元素也参与计算。

哪些元素会生成BFC:
A: 根元素
B: float属性不为none
C: position为absolute或fixed
D: display为inline-block， table-cell, table-caption， flex， inline-flex。
F: overflow 不为visible。
## 兼容问题以及解决方式
1. png23位的图片在IE6浏览器上不显示，解决方案是做成png8。
2. 浏览器默认的margin和padding不同。解决的方案是加一个全局的{margin: 0; padding: 0;}来统一。
3. IE6双边距bug：块属性便签float后，又有横行的margin情况下，在IE6显示margin比设置的大。浮动IE产生的双倍距离'#shot {float: left; width: 10px; margin: 0 0 0 100px;}'这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入`_display: inline；`将其转换为行内属性。（`_`这个符号只有IE6会识别）。
4. IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法: 统一通过getAttribute()获取自定义属性。
5. IE下，even对象有x，y属性，但是么有pageX, pageY属性；Firefox下，event对象有pageX， pageY属性， 但是没有x， y属性。解决方法: (条件注释)缺点是在IE浏览器下可能会增加额外的HTTP请求数。
6. Chrome中文界面下会默认将小于12px的文本强制按照12px来显示，可以通过CSS属性`-webkit-text-size-adjust: none`解决。
7. 超谅解访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是:改变CSS属性的排列顺序: L-V-H-A。 （a: link{} > a: visited{} > a: hover{} > a: active{}）。

## 清除浮动的方式
### 1. 父级div定义height
原理: 父级div手动定义height，就解决了父级div无法自动获取到高度的问题。简单、代码少，容易掌握，但是只适合高度固定的布局。
### 2. 结尾处加空div标签 clear: both;
原理: 在浮动元素的后面添加一个空div兄弟元素，利用css提供的`clear: both`清除浮动， 让父级div能自动获取到高度，如果页面浮动布局多，就要增加很多空div，让人感觉很不好。
### 3. 父级div定义伪类: after和zoom
```css
.clearfix:after{
    content:"";
    display:block;
    visibility:hidden;
    height:0;
    line-height:0;
    clear:both;
}
.clearfix{
	zoom:1
}
```
原理: IE8以上和非IE浏览器才支持:after,原理和方法2有点类似， zoom(IE专有属性)，可以决绝ie6，ie7浮动问题，推荐使用，建议定义公共类，以减少CSS代码。
### 4. 父级div定义overflow:hidden
超出盒子部分会被隐藏，不推荐使用。
### 5. 双伪元素法
```css
.clearfix:before，.clearfix:after {
	content: "";
    display: block; clear:both;
}
.clearfix {
	zoom: 1;
}
```
## px em rem 取用选择依据
1. px像素(Pixel)。绝对单位。像素px是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果px要换算成物理长度，需要制定精度DPI。
2. em是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。
3. rem是CSS3新增的一个相对单位(root em, 根em)，使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。
4. 区别:IE无法调整那些使用px作为单位的字体大小，而em和rem可以缩放，rem相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只是修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8以及更早版本外，所有浏览器均已支持rem。

## CSS权重如何计算
页面显示样式的优先级取决于其“特殊性”，特殊性越高，就显示最高的，当特殊性相等时，显示后者。
特殊性表述为4个部分: 0, 0, 0, 0
一个选择器的特殊性如下：
+ 对于选择器是#id的属性值，特殊性值为:0,1,0,0
+ 队友属性选择器class或伪类，特殊性值为:0,0,1,0
+ 对于标签选择器或伪元素，特殊性值为:0,0,0,1
+ 通配符`*`特殊性值为: 0,0,0,0
+ 内嵌样式的特殊性值为: 1,0,0,0

## 水平垂直居中的方式有几种?
### 1. 绝对定位+转换 absolute + transform
```html
<div class="parent">
<div class="child">Demo</div> </div>
```
```css
.parent {
	position: relative;
}
.child {
	position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}
```
### 2. inline-block + text-align + table-cell + vertical-align (单元格方式)
```html
<div class="parent">
	<div class="child">Demo</div>
</div>
```
```css
.parent {
	text-align: center;
    display: table-cell;
    vertical-align: middle;
}
.child {
	display: inline-block;
}
```
### 3. flex + justify-content + align-items (弹性模型)
```html
<div class="parent">
	<div class="child">Demo</div>
</div>
```
```css
.parent {
	display: flex;
    justify-content: center; /*水平居中*/
    align-items: center; /*垂直居中*/
}
```
## css sorutes（雪碧图/精灵图）如何使用
CSS精灵图，吧一堆小的图片整合到一张大的图片(png)上，减轻服务器对图片的请求数量。再利用CSS的"background-image"、"background-repeat"、"background-position"的组合进行背景定位。
## src与href的区别
src(source)指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时将会将其指向的资源下载并应用到文档中，如js脚本，img图片和我iframe等元素。
当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，类似于将所指向资源嵌入当前标签内。
href(hypertext reference/超文本引用)指向网络资源所在位置，建立和当前元素(锚点)或当前文档(链接)之间的链接，如果我们在文档中添加`<link href="common.css" rel="stylesheet"/>`那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。
## this的理解
this是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能再函数内部使用。
1. 作为纯粹的函数调用，this指向全局。
2. 作为对象的方法调用this指向调用对象。
3. 作为构造函数被调用this指向新的对象(new 会改变this的指向)
4. appy调用this指向。指向apply方法的第一个参数。

## call和apply
在JavaScript中，call和apply都是为了改变某个函数运行时的上下文(context)而存在的，换句话说，就是为了改变函数体内部this的指向。JavaScript的一大特点是，函数存在**定义时上下文**和**运行时上下文**以及**上下文是可以改变的**这样的概念。
先举个例子:
```js
function fruits{}

fruits.prototype = {
	color: "red",
    say: function() {
    	console.log("My color is" + this.color);
    }
}
var apple = new fruits;
apple.say();  // My color is red
```
但是如果我们有一个对象banana={color:"yellow"},我们不想对它重新定义say方法，那么我们可以通过call或apply用apple的say方法:
```js
banana = {
	color: "yellow"
}
apple.say.call(banana);  // My color is yellow
apple.say.apply(banana); // My color is yellow
```
所以，可以看出call和apply是为了动态改变this而出现的，当一个object没有某个方法(本例子中banana没有say方法)，但是其他的有(本例子中apple有say方法)，我们可以借助call或apply用其他对象的方法来操作。
### apply和call的区别
对于apply、call二者而言。作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下:
```js
var func = function (arg1, arg2) {

}
```
就可以通过如下的方式来调用：
```js
func.call(this, arg1, arg2);
func.apply(this, [arg1, arg2]);
```
其中this是你想指定的上下文，他可以是任何一个JavaScript对象(JavaScript中一切皆对象)，call需要把参数**按顺序传递**进去，而apply则是**把参数放在数组里**。
JavaScript中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用call。
而不确定的时候用apply，然后把参数push进数组传递进去。当参数数量不确定时，函数内部也可以通过arguments这个伪数组来遍历所有的参数。
接下来举几个栗子:
#### 数组之间追加
```js
var array1 = [12, "foo", {name "Joe"}, -2458];
var array2 = ["Doe", 555, 100];
Array.prototype.push.apply(array1, array2);
/* array1 值为 [12, "foo", {name "Joe"}, -2458, "Doe", 555, 100] */
```
#### 获取数组中的最大值和最小值
```js
var numbers = [5, 458, 120m -215];
var maxInNumbers = Math.max.apply(Math, numbers), // 458
var	maxInMubers = Math.max.call(Math, 5, 458, 120, -215); // 458
```
nmber本身没有max方法，但是Math有，我们可以借助call或者apply使用其方法。
#### 验证是否是数组(前提是toString()方法没有被重写过)
```js
functionisArray() {
	return Object.prototype.toString.call(obj) === '[object Array]';
}
```
#### 类(伪)数组使用数组方法
```js
var domNodes = Array.prototype.slice.call(document.getElementsByTagName("*"));
```
JavaScript中存在一种名为伪数组的对象结构，比较特别的是**arguments**对象，还有像调用**getElementsByTagName**,**document.childNodes**之类的，它们返回NodeList对象都属于伪数组。不能应用Array下的push，pop等方法。
但是我们能通过Array.prototype.slice.call转换为真正的数组的带有length属性的对象，这样domNodes就可以应用Array下所有方法了。
### 深入理解运用apply， call
定义一个log方法，让它可以代理console.log方法，常见的解决方法是:
```js
function log(msg)　{
  console.log(msg);
}
log(1);    //1
log(1,2);    //1
```
上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用apply或者call，注意这里**传入多少个参数是不确定**的，所以使用apply是最好的，方法如下:
```js
function log(){
  console.log.apply(console, arguments);
};
log(1);    //1
log(1,2);    //1 2
```
接下来的要求是给每一个log消息添加一个“(app)”的前缀，比如:
```js
log("hello world");    //(app)hello world
```
该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过Array.prototype.slice.call转化为标准数组，再使用数组方法unshift，像这样：
```js
function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift('(app)');

  console.log.apply(console, args);
};
```
### bind详解
bind()返回发与apply和call很相似，也是可以改变函数体内this的指向。
MDN的解释是；bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会议创建它时传入bind()方法的第一个参数作为this，传入bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。
直接来看看具体如何使用，在常见的单体模式中，通常我们会使用_this, that, self等保存this，这样我们就可以在改变了上下文之后继续引用到它。像这样:
```js
var foo = {
    bar : 1,
    eventBind: function(){
        var _this = this;
        $('.someClass').on('click',function(event) {
            /* Act on the event */
            console.log(_this.bar);     //1
        });
    }
}
```
由于JavaScript特有的机制，上下文环境在eventBind:function(){}过度到$('.someClass').on('click', function(event){})发生了改变，上述使用变量保存this这些方式都是有用的，也没有什么问题。当然使用bind()可以更加优雅地解决这个问题:
```js
var foo = {
    bar : 1,
    eventBind: function(){
        $('.someClass').on('click',function(event) {
            /* Act on the event */
            console.log(this.bar);      //1
        }.bind(this));
    }
}
```
在上述代码里，bind()创建了一个函数，当这个click事件绑定在被调用的时候，它的this关键词会被设置成被传入的值(这里指调用bind()时传入的参数)。因此，这里我们传入想要的上下问this(其实就是foo)，到bind()函数中。然后，当回调函数被执行的时候，this便指向foo对象。再来一个简单的例子:
```js
var bar = function(){
console.log(this.x);
}
var foo = {
x:3
}
bar(); // undefined
var func = bar.bind(foo);
func(); // 3
```
这里我们创建了一个新的函数func，当使用bind()创建一个绑定函数之后，它被执行的时候，它的this会被设置成foo，而不是我们调用bar()时的全局作用域。
有个有趣的问题，如果连续bind()两次，亦或者是连续bind()三次那么输出的值是什么呢?像这样:
```js
var bar = function(){
    console.log(this.x);
}
var foo = {
    x:3
}
var sed = {
    x:4
}
var func = bar.bind(foo).bind(sed);
func(); //?

var fiv = {
    x:5
}
var func = bar.bind(foo).bind(sed).bind(fiv);
func(); //?
```
答案是，两次都仍将输出3，而非期待中的4和5.原因是，**在JavaScript中，多次bind()是无效的。**更深层次的原因，bind()的实现，相当于使用函数在内部爆了一个call/apply,第二次bind()相当于再报住第一次bind(),故第二次以后的bind是无法生效的。
### apply、call、bind比较
```js
var obj = {
    x: 81,
};

var foo = {
    getX: function() {
        return this.x;
    }
}

console.log(foo.getX.bind(obj)());  //81
console.log(foo.getX.call(obj));    //81
console.log(foo.getX.apply(obj));   //81
```
是哪个输出的都是81， 但是注意看使用bind放阿飞，它后面多了对括号。
也就是说，区别是，**当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用bind()方法。而apply/call则会立即执行函数**。
再总结一下:
+ apply、call、bind三者都是用来改变函数的this对象的指向的；
+ apply、call、bind三者第一个参数都是this要指向的对象，也就是想指定的上下文；
+ apply、call、bind三者都可以利用后续参数传参；
+ bind是返回对应函数，便于稍后调用：apply、call则是立即调用。

## JS有哪些内置对象
Object是JavaScript中所有对象的父对象。
数据封装类对象：Object， Array， Boolean，Number, String
其他对象: Function, Argument, Math, Date, RegExp, Error
## 表单验证传输的什么数据?明文还是暗文(加密)？如何加密？是一次传输数据，还是加密之后才传输？
### 概述
Get是从服务器上请求数据，POST是发送数据到服务器。。事实上，Get方法是吧数据参数队列(query string)加到一个URL上，值和表单是一一对应的。比如说:name=John。在队列里，**值和表单用一个&符号分开，空格用+号替换，特殊的符号转换成十六进制的代码**。因为这一队列在URL里边，这样队列的参数就能看得到，可以被记录下来，或更改。通常Get方法还限制字符的大小(大概是256字节)。
事实上Post方法可以没有时间限制的传输数据到服务器，用户在浏览器端是看不到这一过程的，所以Post方法比较适用于发送一个保密的(比如信用卡号)或者比较大量的数据到服务器。
区别：
Post是允许传输大量数据的方法，而Get方法会将所要传输的数据附在网址后面，然后一起送达服务器，因此传送的数据量就会受到限制，但是执行效率确比Post方法好。
### 总结
1. get方式的安全性较Post方式要差一些，包括机密信息的话，建议用Post数据提交方式。
2. 在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式。

所以：表达如果是向服务器传输数据(如账号密码等)都是加密数据(Post),如果只是单单想要从服务器获得数据或者传输的数据并不重要，可以直接使用明文方式传输(get)。
## 前端跨域总结
### 跨域的定义
只要协议、域名、端口有任何一个不同，就会被当做为不同的域，如果从A域名访问B域名商的资源就叫做跨域。下面是几种跨域的方法。
#### 1. document.domain
浏览器的同源策略有一些限制，
第一，不能通过ajax方法去请求不同源的资源；
第二，浏览器中不同域的框架之间不能进行JS交互。
假如你有一个页面A，地址是`http://www.domain.cn/A.html`,在这个页面里有iframe，它的地址是`http://domain.cn/B.html`，显然A和B是不同域的，所以我们没法通过JS来访问iframe中的数据和方法。
这种情况就可以用document.domain来解决。
解决方法就是把`http://www.domain.cn/A.html`和`http://domain.cn/B.html`的document.domain设成相同的域名，需要注意的是，**我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同**。
+ 在A中我们把设置document.domain:

```js
<iframe id = "iframe" src="http://domain.cn/B.html" onload = "test()"></iframe>
<script type="text/javascript">
    document.domain = 'domain.cn';//设置成主域
    function test(){
        alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象
    }
</script>
```
+ 在B页面中我们也设置document.domain

```js
<script type="text/javascript">
    document.domain = 'domain.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同
</script>
```
但是这种方法只适合不同子域的框架间的交互。
#### 2. location.hash
在一个有iframe页面中，父窗口可以对iframe的URL进行读写，iframe也可以读写父窗口的URL。URL有一部分#加上后面的字符可以用来进行锚点定位，这部分就是hash。利用修改URL的hash部分可以进行双向通信，从而达到跨域的目的。每个window通过改变其他window的location来发送消息，其他窗口通过监听URL变化的事件来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了URL中，数据容量和类型都有限等。下面是一个例子:
加入父页面是`baidu.com/a.html`,iframe嵌入的页面为`google.com/b.html`(此处省略了域名等url属性)，要实现此两个页面间的通信可以通过如下办法:
+ a.html传送数据到b.html,a.html下修改为iframe的src为:`google.com/b.html#paco`。
+ b.html监听到url发生变化，触发相应操作。
+ b.html传送数据到a.html,由于两个页面不再同一个域下IE，Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe。
+ b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如`src="http://www.baidu.com/proxy.ht..."`。
+ proxy.html监听到url发生变化，修改a.html的url(因为a.html和proxy.html同域，所以proxy.html可以修改a.html的url hash)。
+ a.html监听到url发生变化，触发相应操作。

b.html的代码
```js
try {
    parent.location.hash = 'data';
} catch (e) {
    // ie、chrome的安全机制无法修改parent.location.hash，
    var ifrproxy = document.createElement('iframe');
    ifrproxy.style.display = 'none';
    ifrproxy.src = "http://www.baidu.com/proxy.html#data";
    document.body.appendChild(ifrproxy);
}
```
proxy.html页面的关键代码如下:
```js
//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值
parent.parent.location.hash = self.location.hash.substring(1);
```
#### 3. 通过H5的postMessage()
IE8、Chrome、Firefox、Safari、Opera等浏览器都支持这个方法，这个功能主要包括直接接收信息的方法和发送消息的postMessage方法。比如domonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信：
A页面通过postMessage发送消息:
```js
window.onload = function () {
	var ifr = document.getElementById('ifr');
    var targetOrigin = "http://www.google.com";
    ifr.contentWindow.postMessage("hello world!", targetOrigin);
}
```
B页面通过message事件监听并接收消息:
```js
var onmessage = function (event) {
	var data = event.data; // 消息
    var origin = event.origin; // 消息来源地址
    var source = event.source; // 源Window对象
    if (origin == "http://www.baidu.com") {
    	console.log(data); // hellow world!
    }
}
if (typeof window.addEventListener != 'undefined') {
	window.addEvent
}
```