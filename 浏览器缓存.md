# 浏览器缓存
[toc]
## 分类
1. **数据库缓存**
2. **服务器端缓存(代理服务器缓存、CDN缓存)**
3. **浏览器缓存**

而作为前端来说，最常接触的是http缓存与浏览器缓存。
## 缓存的目的是什么
1. 缓存减少了冗余的数据传输，节省了你的网络费用。
2. 缓存缓解了网络瓶颈问题。不需要更多的带宽你就能够更快地加载页面。
3. 缓存降低了对原始服务器的请求。服务器可以更快地响应、避免过载的出现。
4. 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。

举个不恰当的例子：我去手机上可以买火车票，为什么还要开车去火车站买呢？闲的DT，还不如来把王者,我程咬金贼6。
![农药](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571115844834&di=30b3450300ca437f28f87da6b7c6a26e&imgtype=0&src=http%3A%2F%2Fwx4.sinaimg.cn%2Fmw690%2F006HJgYYgy1fg9n2dtrwrg308c08cwf2.gif)

当然缓存无法保存世界上每份文档的副本，可以用已有的副本为某些到达缓存的请求提供服务。这就被称为**缓存命中(cache hit)**。
其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这就被称为**缓存未命中(cache miss)**。具体如下图所示:
![缓存机制](https://user-gold-cdn.xitu.io/2019/10/9/16daeab220229c5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 缓存的处理步骤
### 1. 第一步: 接收---缓存从网络中读取抵达的请求报文
缓存监测到一条网络连接上的活动，读取输入的数据。高性能的缓存会同事从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。
### 2. 第二步：解析---缓存对报文进行解析，提取出URL和各种首部
接下来，缓存将请求报文解析为片段，将首部的各个部分放入易于操作的数据结构中。真央，缓存软件就更容易处理首部字段并修改他们了。
> 解析程序还要负责首部各部分的白哦准话，将大小写或可替换数据格式之类不太重要的区别都看作等效的。而且，某些请求安博文中包含有完整的绝对URL，而其他一些请求中包含的则是相对URL和Host首部，所以解析程序通常都要将这些细节隐藏起来。

### 3. 第三步: 查询---缓存查看时候付有本地副本可用，如果没有，就获取一份副本(并将其保存到本地)
在第三步中，缓存获取了URL，查找本地副本。本地副本可能存储在内存、本地磁盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。如果本地没有这个文档，它可以根据情形和配置，到原始服务器或父代理中去取，或者返回一条错误信息。
已缓存对象中包含了服务器相应主体和原始服务器相应首部，这样就会在华黁命中时返回正确的服务器首部。已缓存对象中还包含了一些元数据(metadata),用来记录对象在缓存中停留了多长时间，以及它被用过多少次等。
> 复杂的缓存还会保留UI你发服务器响应的原始客户端响应首部的一份副本，以用于HTTP/1.1内容协商。

### 4. 第四步: 新鲜度监测---缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新
HTTP通过缓存将服务器文档的副本保留一段时间。在这段时间里，都认为文档是新鲜的，缓存可以在不联系服务器的情况下，直接提供该文档。但是一旦已缓存到副本停留的时间太长，超过了文档的新鲜度限值(freshness limit),就认为对象"过时"了，在提供该文档之前，缓存要再次与服务器进行确认，已查看文档是否发生了变化。客户端发送给缓存的所有请求首部都可以强制缓存进行在验证，或者完全避免验证，这使得事情变得更加复杂了。
HTTP有一组非常复杂的新鲜度监测规则，缓存产品支持的大量配置选项，以及与非HTTP新鲜度白哦准进行互通的需要则使温蒂变得更加严重了。
### 5. 第五步: 创建相应---缓存会用心的首部和已缓存的主题来构建一条相应报文
我们虚妄缓存的响应看起来就像来自原始服务器一样，缓存将已缓存的服务器响应首部作为响应首部的七点，然后缓存对这些基础首部进行了修改和扩充。
缓存负责对这些首部进行改造，以便与客户端的要求相匹配。比如，服务器返回的可能是一条HTTP/1.0响应(甚至可能是HTTP/0.9响应)，而客户端期待的是一条HTTP/1.1响应，在这种情况下，缓存必须对首部进行相应的转换。缓存还会向其中插入新鲜度信息(Cache-Control、Age以及Expires首部)，而且通常包含一个Via首部来说明请求是由一个代理缓存提供的。
> 注意，缓存不应该调整Date首部。Date首部表示的是原始服务器最初产生这个对象的日期。

### 6. 第六步: 发送---缓存通过网络将响应发回给客户端
一旦响应首部准备好了，缓存就将响应回送给客户端。和所有代理服务器一样，代理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效地发送数据，通常可以避免在本地缓存和网络I/O缓冲区之间进行文档内容的赋值。
### 7. 第七步: 日志---缓存可选地创建一个日志文件条目来描述这个事务
大多数缓存都会保存日志文件以及与缓存的使用有关的一些统计数据。每个缓存事务结束之后，缓存都会更新缓存命中和未命中数据的统计数据(以及其他相关的度量值)，并将条目插入一个用来显示请求类型、URL和所发生事件的日志文件。
下面是一张总结图:
![缓存处理步骤](https://user-gold-cdn.xitu.io/2019/10/9/16daf31b4d73655e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 强缓存